## **Dart学习笔记:**
## **目录：**
### 语法基础知识：
-------------
### 变量：
--------------
创建变量并初始化：  
`var name = "Bob"`  
变量存储的是引用。名为`name`的变量包含对值为`Bob`的`String`对象的引用.  
变量`name`的类型被推断为`String`，但你可以通过指定来更改它。如果对象不受单一类型的限制，请指定`Object`类型（或必要时指定 dynamic）  
`Object name = "Bob";`  
即使变量或表达式的类型可以从上下文中推断出来，你也可以显式的指定其类型，这可以使代码更易读或可维护，并防止错误：  
`String name = "Bob";`
>注意：遵循编码风格指南，即对局部变量使用`var`而不是类型注解  
---------
**空安全**：  
`Dart` 语言强制执行严格的空安全。  
空安全可以防止由于无意中访问被设置为`null`的变量而导致的错误。这种错误称为空指针引用错误。当访问一个表达式（该表达式求值为`null`）的属性或调用其方法时，就会发生空指针引用错误。此规则的一个例外是当`null`支持属性或方法时，例如`toString()`或`hashCode`.通过空安全性，`Dart`编译器可以在编译时检测到这些潜在错误。
例如，假设您要找到一个 `int` 变量 `i` 的绝对值。如果 `i` 为`null`，调用 `i.abs()` 会导致空指针引用错误。在其他语言中，这样做可能会导致运行时错误，但 `Dart` 的编译器禁止这种操作。因此，`Dart` 应用程序不会导致运行时错误。
空安全性引入的三个关键变化：  
1. 当你为变量，参数或其他相关组件指定类型时，你可以控制该类型是否允许值为`null`，要启用可空性，可以在类型声明末尾添加`？`
```
String ? name  // Nullable type.Can be "null" or String
String name // Non-nullable type,cannot be "null" but can be Strings
```
2. 你必须在使用变量之前初始化它们。可空变量默认为`null`,所以它们默认被初始化。`Dart`不会为非可空类型设置初始值。它强制你设置一个初始值。`Dart`不允许你设置一个未初始化的变量。这避免了你访问属性或调用方法,其中接收者的类型可以是`null`,但`null`不支持所用的方法或属性。  
3. 你不能在一个可空类型的表达式上访问属性或调用方法。同样的规则也适用于那些`null`支持的属性或方法,像`hashCode`或`toString()`。  

可靠的空安全性将运行时错误(`runtime errors`)改变为编辑时(` edit-time`)的分析错误。当一个非空变量出现以下情况时,空安全性会标记它:
- 没有使用非空值初始化。
- 被赋予了null值。  

这种检查允许你在部署应用程序之前修复这些错误

---
**默认值:**  
可空类型的未初始化变量具有初始值`null`.即使是数值类型的变量，最初也是`null`，因为在`Dart`中数字也像其他所有内容一样，都是对象。
```
int ? lineCount;
assert(lineCount == null);
```
对于空安全来讲，在使用不可空变量之前必须初始化它们：`int lineCount = 0;` 

不必在声明的地方初始化局部变量，但需要在使用之前为其赋值。例如:下面的代码是有效的，因为`Dart`可以在传递给`print()`时检测到`lineCount`为非空。

顶级变量和类变量是延迟初始化的。初始化代码在第一次使用变量时运行。

---
**延迟变量：**  
late修饰词有两个用法 ：  
- 声明一个不为null的变量，该变量在声明之后进行初始化。
- 延迟初始化变量。 

Dart的控制流分析通常可以检测到一个非空变量在使用前被设置了一个非空值,但有时会失败。两种常见情况是顶级变量和实例变量:Dart通常无法确定它们是否被设置,所以不会尝试去分析。  
如果你确定一个变量在使用前已经被设置了,但是Dart不这么认为,你可以通过将该变量标记为late来修复错误:
```
late String description;

void main() {
  description = 'Feijoada!';
  print(description);
}
```
>警告:如果未能初始化延迟变量，则在使用该变量时会出现运行时错误。  

当你将一个变量标记为`late`但在声明时初始化它时，初始化器会在第一次使用该变量时运行。这种延迟初始化在以下几种情况下很方便：
- 该变量可能不需要，且初始化它的成本很高
- 你正在初始化一个实例变量，并且它的初始化器需要访问`this`  

在下面的例子中。如果`temperature`变量从未被使用,那么昂贵的`readThermometer()`函数就永远不会被调用
```
class Thermostat {
  late final temperature = readThermometer(); // 懒加载初始化

  // ...
}
```
所以对于不确定是否需要的昂贵初始化，可以使用`late`关键字实现延迟并懒加载。


